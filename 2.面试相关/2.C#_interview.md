# C# interview questions

<!-- 
// 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣
-->
<b><details><summary>1.`String s;`和`String s=null;`和`String s="a";`有什么区别？</summary></b>

参考答案：

`String s`;该语句表示只是声明了一个引用变量,但是并没有初始化引用,所以对变量`s`的任何操作(除了初始化赋值外) 都将引发异常. 

`String s=null;` 表示未申请任何内存资源，即些语句表示声明了一个引用变量并初始化引用,但是该引用没有指向任何对象.但可以把它作为参数传递或其它使用,但是不能调用它作为对象的方法

`String s="";` 表示申请了**内存资源**，但资源空间值为空。该语句表示声明并引用到一个对象,只不过这个对象为0个字节.所以既然有了对象,就可以调用对象的方法
注意：`""` 也是字符串
`String s = String.Empty` 与 `String s=""`; 是完全相同的

`String s;`不给初始值默认为`null`，成员变量

`String s = null;`等同于`String s`;

如果定义为**局部变量**(如在方法中定义，必须给其赋初始值)，`String s=null;String s="";`都行。

`String s = ""`与`String s = null`还是有区别的，我们平常做字符串空值判断的时候都会对两者进行判断
`if("".equals(s) && s==null)`

</details>

<b><details><summary>2.`Func`与`Action`</summary>
 
 参考答案：
 
 * [`Func`](https://docs.microsoft.com/en-us/dotnet/api/system.func-2?view=net-5.0)是.NET里面的内置委托，它有很多重载,返回类型为`TResult`的委托,可传入参数，也可不传，通过重载实现

 *  [`Action<T>`](https://docs.microsoft.com/en-us/dotnet/api/system.action-1?view=net-5.0) 委托：传入参数为T，没有返回类型。

 两者最大的区别在于 `Func` 有返回类型； `Actiion` 没有返回类型

下面讲一些用法吧

以下是一段平时调用委托的方法

```C#
// 声明委托方法，string说明适用于这个委托的方法的返回类型是string类型，委托名Say后面没有参数，说明对应的方法也就没有传入参数。
private delegate string Say();

// 适用于该委托的方法
public static string SayHello()
{
    return "Hello";
}

static void Main(string[] args)
{
    Say say = SayHello;
    // 调用委托
    Console.WriteLine(say());
}
```

问题：这里先声明委托，然后再将方法传给该委托。有没有办法可以不定义委托变量呢？
答案是肯定的，我们可以用`Func`.

`Func`是.NET里面的内置委托，它有很多重载。

`Func<TResult>`：没有传入参数，返回类型为`TResult`的委托。就像我们上面的`Say`委托，就可以用`Func<string>`来替代，调用如下：

```C#
static void Main(string[] args)
{
    Func<string> say = SayHello;
    //Say say = SayHello;
    Console.WriteLine(say());
}
```

看起来变简单了吧。看一下`Func`别的重载。

* `Func<T, TResult>`委托：有一个传入参数`T`，返回类型为`TResult`的委托。如：

```C#
//委托 传入参数类型为string,方法返回类型为int
Func<string, int> a = Count;
//对应方法
public int Count(string num)
{
    return Convert.ToInt32(num);
}
```

* `Func<T1, T2, TResult>` 委托：有两个传入参数：`T1`与`T2`，返回类型为`TResult`。

类似的还有`Func(T1, T2, T3, TResult)` 委托、`Func(T1, T2, T3, T4, TResult)` 委托等。用法差不多，都是前面为方法的传入参数，最后一个为方法的返回类型。

`Func`也可以与**匿名方法**一起使用如：

```C#
public static void Main()
{
    Func<string, int, string[]> extractMeth = delegate(string s, int i)
    {
        char[] delimiters = new char[] { ' ' };
        return i > 0 ? s.Split(delimiters, i) : s.Split(delimiters);
    };

    string title = "The Scarlet Letter";
    // Use Func instance to call ExtractWords method and display result
    foreach (string word in extractMeth(title, 5))
        Console.WriteLine(word);
}
```

同样它也可以接 `lambda` 表达式

```C#
public static void Main()
{
    char[] separators = new char[] {' '};
    Func<string, int, string[]> extract = (s, i) => 
        i > 0 ? s.Split(separators, i) : s.Split(separators) ;

    string title = "The Scarlet Letter";
    // Use Func instance to call ExtractWords method and display result
    foreach (string word in extract(title, 5))
        Console.WriteLine(word);
}
```

`Func`都是有返回类型的，如果我们的方法没有返回类型时候可以使用`Action`。

`Action`委托：没有传入参数，也没有返回类型，即 `void`。如：

```C#
static void Main(string[] args)
{
    Action say = SayHello;
    say();
}

public static void SayHello( )
{
    Console.WriteLine("Say Hello");
}
```

`Action<T>` 委托：传入参数为 `T`，没有返回类型。如：

```C#
static void Main(string[] args)
{
    Action<string> say = SayHello;
    say("Hello");
}
public static void SayHello(string word )
{
    Console.WriteLine(word);
}
```

`Action<T1, T2>` 委托:两个传入参数，分别为`T1`与`T2`，没有返回类型。

`Action`同样的还有许多其它重载，每个重载用法一样，只是方法的传入参数数量不一样。

其实`Action`与`Func`的用法差不多，差别只是一个有返回类型，一个没有返回类型，当然`Action`也可以接**匿名方法**和**Lambda**表达式。

```C#
static void Main(string[] args)
{
    Action<string> say = delegate(string word)
    {
        Console.WriteLine(word);
    };
    say("Hello Word");
}
```

Lambda表达式

```C#
static void Main(string[] args)
{
    Action<string> say = s => Console.WriteLine(s);
    say("Hello Word");
}
```

</details>



